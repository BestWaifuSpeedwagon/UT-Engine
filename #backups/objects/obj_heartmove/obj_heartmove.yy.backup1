// 2020-12-22 14:51:10
#event properties (no comments/etc. here are saved)
parent_index = -1;
sprite_index = spr_heart;
uses_physics = false;

#event create Variables
color = RED;

x = Box.cx;
y = Box.cy;

inv = 0; //Invicibility time
visible = false;

canMove = true;

customFunc = NULL; //Will be run for specific colors

//BLUE
onGround = true;
velY = 0;
gravityDir = pi/2; //Down by default
slam = false; //SLAM DUNK when you touch box

/// @param {obj_attack} _atk
function applyDamage(_atk)
{
	audio_play_sound(snd_hurt1, 1, false);

	obj_stat.hp -= _atk.damage;
	
	if(obj_soul.karma) obj_soul.kr++;
	
	inv = room_speed;
	
	if(_atk.turnIntoColor) color = _atk.color;
	if(_atk.destroy) instance_destroy(_atk);
}

function changeColor(_color)
{
	if(color == _color) return; //If color is already color
	
	audio_play_sound(snd_bell, 0, false);
	color = _color;
}

#event step Collision
#region Attacks
if(visible && (inv == 0 || obj_soul.karma))
{
	var moved = (xprevious != x || yprevious != y);
	
	var _atkCount = instance_number(obj_attack);
	for(i = 0; i < _atkCount; i++)
	{
		var _atk = instance_find(obj_attack, i);
	
		if(!_atk.collision) continue; //No need to check if collision is deactivated
		if(color == AQUA && !moved || color == ORANGE && moved) continue; //No need to check if no damage would have happened
		
		if(_atk.boundingAmount > 1)
		{
			var _colOccured = false;
			
			//Check over every bounding box and break if a collision happen
			for(j = 0; j < _atk.boundingAmount; j++)
			{
				//Smart operators will check if color is AQUA then if it's already on, and only then for collision 
				canMove = color != AQUA || canMove || _atk.bounding[@ j].checkCircle(x, y, 32);
				
				//Can't have a collision if you're not close to any
				if(canMove && _atk.bounding[@ j].checkPoint(x, y))
				{
					applyDamage(_atk);
					_colOccured = true;
					break; //Break out of bounding box loop if collision happened
				}
			}
			
			if(_colOccured) break; //Break out of attacks loop if collision happened
		}
		else
		{
			//Smart operators will check if color is AQUA then if it's already on, and only then for collision 
			canMove = color != AQUA || canMove || _atk.bounding.checkCircle(x, y, 32);
			
			if(canMove && _atk.bounding.checkPoint(x, y))
			{
				applyDamage(_atk);
				break;
			}
		}
	}
}
else inv--;

#endregion

#event step_begin Movement
#region Movement
if(visible && canMove)
{
	switch(color)
	{
		case AQUA:
		case RED:
			var hspd = keyboard_check(vk_right) - keyboard_check(vk_left);
			var vspd = keyboard_check(vk_down) - keyboard_check(vk_up);
		
			x += hspd*3;
			y += vspd*3;
			break;
		case BLUE: //https://www.reddit.com/r/Underminers/comments/3yq1nn/physics_for_blue_soul/
			var hspd = keyboard_check(vk_right) - keyboard_check(vk_left);
			x += hspd*3;
			
			//if(onGround) velY = max(0, velY);
			
			if(onGround && keyboard_check_pressed(vk_up)) velY = -6/2;
			
			if(velY <= -4/2) velY += 0.2/4;
			else if(velY <= -1/2) velY += 0.5/4;
			else if(velY <= -0.5/2) velY += 0.2/4;
			else if(velY < 8/2) velY += 0.6/4;
				
			if(keyboard_check_released(vk_up)) velY = max(velY, -1);
			
			x += cos(gravityDir)*velY;
			y += sin(gravityDir)*velY;
			
			//Check for all angles
			onGround = !pointInRectangleRotated(x, y, Box.x+2, Box.y+2, Box.x2-18, Box.y2-18, Box.w/2-8, Box.h/2-8, gravityDir - pi/2, true);
			
			if(slam && onGround)
			{
				screenShake(10);
				audio_play_sound(snd_impact, 3, false);
				
				slam = false;
			}
			break;
	}
}

switch(color)
{
	case AQUA:
		canMove = false; //Reset to false
		break;
	default:
		canMove = true;
		break;
}

///TODO : Add rotation of box
x = clamp(x, Box.x+8, Box.x2-8); //Sprite width/height
y = clamp(y, Box.y+8, Box.y2-8);

pos.set(x, y);

#endregion

#event draw Draw myself
var _rot = 0;
switch(color)
{
	case AQUA:
		draw_set_color(canMove ? c_lime : c_white);
		draw_circle(x, y, 32, true);
		break;
	case BLUE:
		_rot = -radtodeg(gravityDir)+90;
		break;
}

draw_sprite_ext(sprite_index, inv % 20 < 10 ? 0 : 1, x, y, 1, 1, _rot, color, 1.0); //1 frame on 2 every 6 step